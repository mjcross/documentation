== Serial connections

Ensure that the Debug Probe is connected to the UART pins of your Raspberry Pi Pico.

image:images/wiring.png[width="80%"]

The default pins for Raspberry Pi Pico UART0 are as follows:

[cols="1,1,1"]
|===
| Default UART0 | Physical Pin | GPIO Pin

| GND | 3 | N/A
| UART0_TX | 1 | GP0
| UART0_RX | 2 | GP1
|===

Once connected, traffic over the Raspberry Pi Pico's UART will be relayed to your computer by the Debug Probe and exposed as a CDC UART. On a Raspberry Pi this will show up as `/dev/ttyACM0`; on other platforms this serial port will show up differently (e.g. on macOS it will appear as `/dev/cu.usbmodemXXXX`).

If you have not already done so you should install minicom:

[source,console]
----
$ sudo apt install minicom
----

and open the serial port:

[source,console]
----
$ minicom -b 115200 -o -D /dev/ttyACM0
----

TIP: To exit `minicom`, use CTRL-A followed by X.

To test serial communication you can build and upload the "Hello World" example application.

Change directory into the `hello_world` directory inside the `pico-examples` tree, and run `make`. Afterwards, you can upload it to your Raspberry Pi Pico using `openocd`. For a full walkthrough of building the `hello_serial` example program, see Chapter 4 of https://pip.raspberrypi.com/documents/RP-008276-DS[Getting started with Raspberry Pi Pico].

[source,console]
----
$ cd pico-examples
$ mkdir build
$ cd build
$ export PICO_SDK_PATH=../../pico-sdk
$ cmake ..
$ cd hello_world/serial
$ make -j4
$ sudo openocd -f interface/cmsis-dap.cfg -f target/rp2040.cfg -c "adapter speed 5000" -c "program hello_serial.elf verify reset exit"
$ minicom -b 115200 -o -D /dev/ttyACM0
----

On opening `minicom` you should see "Hello, world!" printed to the console.

For terminal programs that support it, a description of the USB serial UART is advertised in the USB device description.

image::images/description.jpg[width="60%"]

The unique serial number in this description means that on Windows your COM port numbering is "sticky" per device, and will allow you to write `udev` rules to associate a named device node with a particular Debug Probe.

== Send stdio over SWD using RTT

You can, if desired, avoid using a serial link and send your application's output directly over the SWD interface by using a mechanism called Segger Real-Time Transport (RTT), that is supported by both the C/C++ SDK and the Debug Probe.

NOTE: you will only be able to see the output over SWD from a *debug build* of your application.

Sending stdio over RTT requires two steps: enabling the driver when building your application, and connecting to it with the Debug Probe.

=== Enabling RTT in your build

The C/C++ SDK provides a stdio driver for RTT just like the ones for UART and USB (see https://www.raspberrypi.com/documentation/pico-sdk/runtime.html#group_pico_stdio_rtt[pico_stdio_rtt] in the API documentation).

To use the driver you must enable it by including the following line in your `CmakeLists.txt` file (or some other means of linking with `pico_stdio_rtt`):

[source,console]
----
pico_enable_stdio_rtt(test_stdio_rtt 1)
----

After that you can just call `stdio_init_all()` and `printf()` and so on as normal. So with the exception of that change you can just use the `hello_serial` example program as described above.

=== Connecting to RTT from VSCode

RTT is supported by `openocd` and the VSCode https://marketplace.visualstudio.com/items?itemName=marus25.cortex-debug[Cortex-Debug] extension, both of which should have been set up as part of https://github.com/raspberrypi/documentation/blob/master/documentation/asciidoc/microcontrollers/debug-probe/installing-tools.adoc#install-tools[installing the tools]. If preferred you can also control `openocd` manually via `gdb` as described in the following section.

With Cortex-Debug, open *launch.json* in your project's `.vscode` folder and add the following section to the *"Pico Debug (Cortex-Debug)"* configuration:

[source,console]
----
"rttConfig": {
    "enabled": true,
    "address": "auto",
    "decoders": [
        {
            "label": "",
            "port": 0,
            "type": "console"
        }
    ]
}
----

Now connect the debug probe, launch your application with *"Pico Debug (Cortex-Debug)"* and open the *TERMINAL* tab in the lower pane of the VSCode window. In the list of terminals at the right you should now see one called `RTT Ch:0 console`. Select this to see any output that your application sends to the `pico_stdio_rtt` driver.

For a list of all the `cortex-debug` attributes that can be included in *launch.json* see the https://github.com/Marus/cortex-debug/blob/master/debug_attributes.md[documentation].

=== Connecting to RTT in a standalone debug session

If you are using a standalone debug session as described in https://github.com/raspberrypi/documentation/blob/master/documentation/asciidoc/microcontrollers/debug-probe/swd-connection.adoc#standalone-debug-session[Starting a Debug Session] then you can connect to RTT as follows.

Build and upload your RTT-enabled application, then connect the Debug Probe and start `openocd` and `gdb` separate terminals https://github.com/raspberrypi/documentation/blob/master/documentation/asciidoc/microcontrollers/debug-probe/swd-connection.adoc#standalone-debug-session[as described before].

At the `gdb` prompt enter the following commands:

[source,console]
----
(gdb) target remote localhost:3333
(gdb) monitor reset init
(gdb) monitor rtt setup 0x20000000 2048 "SEGGER RTT"
(gdb) monitor rtt start
(gdb) monitor rtt server start 60000
(gdb) continue
----

Note that `gdb` commands prefixed with `monitor` are passed through to `openocd`, so for details of the commands used here see https://openocd.org/doc/html/General-Commands.html[section 15.6] of the OpenOCD Manual.

You should see messages as `rtt` searches for a control block on the target and then listens for connections to a local TCP socket on port 60000.

Finally open a third window and connect to the local socket with a tool like `nc` (netcat) or equivalent to see the output from the application:

[source,console]
----
$ nc localhost 60000
----